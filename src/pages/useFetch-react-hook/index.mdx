---
title: 'useFetch — A Custom React Hook'
summary: 'Often we see ourselves writing almost the same exact codes in more than one different component. What about extracting that recurrent logic into a reusable piece of code (hook) and reuse it where the need be?'
publishedAt: '2020-05-24'
---

One of the most common React Hooks that I’ve found myself using is one to handle API calls. Often we see ourselves writing almost the same exact codes in more than one different component. Ideally what we could do in such cases would be to extract that recurrent logic into a reusable piece of code (hook) and reuse it where the need be.

I am going to use [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) for the HTTP calls. You can use [axios](https://github.com/axios/axios) as well, it's up to you.

## This custom hook will support/include these features:

- [Loading Indicator](#loading-indicator)
- [Error Handling](#error-handling)
- [Using On didMount or Some After](#using-on-didmount-or-some-after)
- [Dynamic Url](#dynamic-url)
- [Dynamic Parameters](#dynamic-parameters)
- [Manual Refetch](#manual-refetch)

---

Without using a custom hook, you would probably do something similar to this:

```jsx:components/foo.js
import React, { useState, useEffect } from 'react'

const Foo = () => {
  const url = 'some url'
  const [data, setData] = useState(null)

  useEffect(() => {
    const fetchData = async () => {
      fetch(url)
        .then((response) => response.json())
        .then((result) => {
          setData(result)
        })
    }
    fetchData()
  }, [])

  if(!data) return null

  return (
    <div>
      {data.map((item, itemIndex) => (
        ...
      ))}
    </div>
  )
}

export default Foo
```

To convert this example to a custom hook, it would look like this:

```jsx:hooks/useFetch.js
import { useState, useEffect } from 'react'

const useFetch = (url) => {
  const [data, setData] = useState(null)

  useEffect(() => {
    const fetchData = async () => {
      fetch(url)
        .then((response) => response.json())
        .then((result) => {
          setData(result)
        })
    }
    fetchData()
  }, [])

  return { data }
}

export default useFetch
```

This is a very basic example that has many issues; not including handling errors, loading indicator, etc. It’s already quite a bit a few lines of code, and is obviously not reusable.

Our component could then call it like this:

```jsx:component/foo.js
const url = 'some url'
const { data } = useFetch(url)
```

Let's start to add the features I mentioned above.

## Loading Indicator

The loading indicator is a must in my opinion. Because knowing the fetch process still goes on, we can show a loading component or an icon or something else for nice user experience.

Let's define a state for loading to achieve that.

```jsx{5,9,14,20}:hooks/useFetch.js
import { useState, useEffect } from 'react'

const useFetch = (url) => {
  const [data, setData] = useState(null)
  const [isLoading, setIsLoading] = useState(false) // Here is our state for loading indicator

  useEffect(() => {
    const fetchData = async () => {
      setIsLoading(true) // We’ll set it to true when the fetching process starts
      fetch(url)
        .then((response) => response.json())
        .then((result) => {
          setData(result)
          setIsLoading(false) // We’ll set it to false when we are done with setting data
        })
    }
    fetchData()
  }, [])

  return { data, isLoading } // And here, we’ll return our loading indicator state to use it on our component
}

export default useFetch
```

Our component could use it like this:

```jsx{2,4}:components/foo.js
const url = 'some url'
const { data, isLoading } = useFetch(url)

if (isLoading) return <LoadingComponent />
```

## Error Handling

Here is another must feature for our custom hook. We’ll define 2 states, one is a boolean value that indicates whether has an error or not and another one is a string value that includes the error message.

We’ll be also using the `try/catch` syntax to set and handle error boundaries. It would look like this:

```jsx{6,7,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,31}:hooks/useFetch.js
import { useState, useEffect } from 'react'

const useFetch = (url) => {
  const [data, setData] = useState(null)
  const [isLoading, setIsLoading] = useState(false)
  const [hasError, setHasError] = useState(false)
  const [errorMessage, setErrorMessage] = useState('')

  useEffect(() => {
    const fetchData = async () => {
      setIsLoading(true)
      try {
        const response = await fetch(url)
        const result = await response.json()
        if (response.ok) {
          setData(result)
        } else {
          setHasError(true)
          setErrorMessage(result)
        }
        setIsLoading(false)
      } catch (err) {
        setHasError(true)
        setErrorMessage(err.message)
        setIsLoading(false)
      }
    }
    fetchData()
  }, [])

  return { data, isLoading, hasError, errorMessage }
}

export default useFetch
```

Our component could use it like this:

```jsx{2,4}:components/foo.js
const url = 'some url'
const { data, isLoading, hasError, errorMessage } = useFetch(url)

if (hasError) return <ErrorComponent message={errorMessage} />
```

## Using On didMount or Some After

What if we would like to use this hook some after the component renders rather than _didMount_ stage. To achieve this, we can use a prop (let's say: **skip**) to skip the data fetching function.

> We’ll define it `false` by default to use fetching on _didMount_ stage.

```jsx{3,11}:hooks/useFetch.js
import { useState, useEffect } from 'react'

const useFetch = (url, skip = false) => {
  const [data, setData] = useState(null)
  const [isLoading, setIsLoading] = useState(false)
  const [hasError, setHasError] = useState(false)
  const [errorMessage, setErrorMessage] = useState('')

  useEffect(() => {
    const fetchData = async () => {
      if (skip) return
      setIsLoading(true)
      try {
        const response = await fetch(url)
        const result = await response.json()
        if (response.ok) {
          setData(result)
        } else {
          setHasError(true)
          setErrorMessage(result)
        }
        setIsLoading(false)
      } catch (err) {
        setHasError(true)
        setErrorMessage(err.message)
        setIsLoading(false)
      }
    }
    fetchData()
  }, [])

  return { data, isLoading, hasError, errorMessage }
}

export default useFetch
```

Our component could use it like this:

```jsx{2}:components/foo.js
const url = 'some url'
const { data, isLoading, hasError, errorMessage } = useFetch(url, (skip = true))
```

## Dynamic Url

What if we would like to change the url dynamically to trigger the fetching process again? Why not? Let's implement it.

We’ll change the `url` prop name to `initialUrl` to use it as a state. The `initialUrl` prop will be the default value of the `url` state.

We’ll add `url` state to the dependency of the `useEffect` hook to trigger it again. Then we’ll export its `setState` function which is `updateUrl` to use it from our component.

```jsx{3,4,31,33}:hooks/useFetch.js
import { useState, useEffect } from 'react'

const useFetch = (initialUrl, skip = false) => {
  const [url, updateUrl] = useState(initialUrl)
  const [data, setData] = useState(null)
  const [isLoading, setIsLoading] = useState(false)
  const [hasError, setHasError] = useState(false)
  const [errorMessage, setErrorMessage] = useState('')

  useEffect(() => {
    const fetchData = async () => {
      if (skip) return
      setIsLoading(true)
      try {
        const response = await fetch(url)
        const result = await response.json()
        if (response.ok) {
          setData(result)
        } else {
          setHasError(true)
          setErrorMessage(result)
        }
        setIsLoading(false)
      } catch (err) {
        setHasError(true)
        setErrorMessage(err.message)
        setIsLoading(false)
      }
    }
    fetchData()
  }, [url])

  return { data, isLoading, hasError, errorMessage, updateUrl }
}

export default useFetch
```

Our component could use it like this:

```jsx{2,4,5,6}:components/foo.js
const url = 'some url'
const { data, isLoading, hasError, errorMessage, updateUrl } = useFetch(url)

if(...) updateUrl('some another url')
```

## Dynamic Parameters

What about parameters? And what about changing it dynamically to use it like filtering or something else? Sounds great. Let's implement this too.

We’ll take parameters as a prop which will be an object. And then, we’ll transpile them with `encodeURIComponent` to use properly. Following that, we’ll add `params` state to the dependency of the `useEffect` hook to trigger it again. It would look like this:

```jsx{3,5,11,12,13,20,36,38}:hooks/useFetch.js
import { useState, useEffect } from 'react'

const useFetch = (initialUrl, initialParams = {}, skip = false) => {
  const [url, updateUrl] = useState(initialUrl)
  const [params, updateParams] = useState(initialParams)
  const [data, setData] = useState(null)
  const [isLoading, setIsLoading] = useState(false)
  const [hasError, setHasError] = useState(false)
  const [errorMessage, setErrorMessage] = useState('')

  const queryString = Object.keys(params)
    .map((key) => encodeURIComponent(key) + '=' + encodeURIComponent(params[key]))
    .join('&')

  useEffect(() => {
    const fetchData = async () => {
      if (skip) return
      setIsLoading(true)
      try {
        const response = await fetch(`${url}${queryString}`)
        const result = await response.json()
        if (response.ok) {
          setData(result)
        } else {
          setHasError(true)
          setErrorMessage(result)
        }
        setIsLoading(false)
      } catch (err) {
        setHasError(true)
        setErrorMessage(err.message)
        setIsLoading(false)
      }
    }
    fetchData()
  }, [url, params])

  return { data, isLoading, hasError, errorMessage, updateUrl, updateParams }
}

export default useFetch
```

Our component could use it like this:

```jsx{2,4,5,6,7,11,12,13,14}:components/foo.js
const url = 'some url'
const { data, isLoading, hasError, errorMessage, updateUrl, updateParams } = useFetch(
  url,
  (initialParams = {
    id: 123456789,
    query: 'Lorem Ipsum'
  }) // will be transpiled as 'id=123456789&query=Lorem%20Ipsum'
)

if(...) {
  updateParams({
    id: 4815162342,
    query: 'Dharma Initiative'
  }) // will be transpiled as 'id=4815162342&query=Dharma%20Initiative'
}
```

## Manual Refetch

Another common thing I’ve needed is the ability to manually trigger the API call again. A good example would be a page with a list of resources and want to refresh the list from a callback after creating a new resource.

To do this we’ll simply keep a number in the state that’s a dependency one the `useEffect`, that we increment every time we want to force a refresh.

Finally, it would look like this:

```jsx{10,16,39,41}:hooks/useFetch.js
import { useState, useEffect } from 'react'

const useFetch = (initialUrl, initialParams = {}, skip = false) => {
  const [url, updateUrl] = useState(initialUrl)
  const [params, updateParams] = useState(initialParams)
  const [data, setData] = useState(null)
  const [isLoading, setIsLoading] = useState(false)
  const [hasError, setHasError] = useState(false)
  const [errorMessage, setErrorMessage] = useState('')
  const [refetchIndex, setRefetchIndex] = useState(0)

  const queryString = Object.keys(params)
    .map((key) => encodeURIComponent(key) + '=' + encodeURIComponent(params[key]))
    .join('&')

  const refetch = () => setRefetchIndex((prevRefetchIndex) => prevRefetchIndex + 1)

  useEffect(() => {
    const fetchData = async () => {
      if (skip) return
      setIsLoading(true)
      try {
        const response = await fetch(`${url}${queryString}`)
        const result = await response.json()
        if (response.ok) {
          setData(result)
        } else {
          setHasError(true)
          setErrorMessage(result)
        }
        setIsLoading(false)
      } catch (err) {
        setHasError(true)
        setErrorMessage(err.message)
        setIsLoading(false)
      }
    }
    fetchData()
  }, [url, params, refetchIndex])

  return { data, isLoading, hasError, errorMessage, updateUrl, updateParams, refetch }
}

export default useFetch
```

It could be then used in a way similar to this:

```jsx{2,4}:components/foo.js
const url = 'some url'
const { data, isLoading, hasError, errorMessage, updateUrl, updateParams, refetch } = useFetch(url)

return <button onClick={refetch} />
```

## Finally

Have you noticed that we're setting `isLoading` state in `response.ok`, its `else` and `catch` cases? Let's use `finally` syntax for better development. It'll look like this:

```jsx{34,35,36}:hooks/useFetch.js
import { useState, useEffect } from 'react'

const useFetch = (initialUrl, initialParams = {}, skip = false) => {
  const [url, updateUrl] = useState(initialUrl)
  const [params, updateParams] = useState(initialParams)
  const [data, setData] = useState(null)
  const [isLoading, setIsLoading] = useState(false)
  const [hasError, setHasError] = useState(false)
  const [errorMessage, setErrorMessage] = useState('')
  const [refetchIndex, setRefetchIndex] = useState(0)

  const queryString = Object.keys(params)
    .map((key) => encodeURIComponent(key) + '=' + encodeURIComponent(params[key]))
    .join('&')

  const refetch = () => setRefetchIndex((prevRefetchIndex) => prevRefetchIndex + 1)

  useEffect(() => {
    const fetchData = async () => {
      if (skip) return
      setIsLoading(true)
      try {
        const response = await fetch(`${url}${queryString}`)
        const result = await response.json()
        if (response.ok) {
          setData(result)
        } else {
          setHasError(true)
          setErrorMessage(result)
        }
      } catch (err) {
        setHasError(true)
        setErrorMessage(err.message)
      } finally {
        setIsLoading(false)
      }
    }
    fetchData()
  }, [url, params, refetchIndex])

  return { data, isLoading, hasError, errorMessage, updateUrl, updateParams, refetch }
}

export default useFetch
```

## Conclusion

In this post, I have explained and made a small demo to show how we can declaratively fetch data and render it on screen by using the `useFetch` hook with the native Fetch API.

> If you are using Next.js, I highly recommend you to use [SWR](https://swr.now.sh/) by Vercel instead of this custom hook.
